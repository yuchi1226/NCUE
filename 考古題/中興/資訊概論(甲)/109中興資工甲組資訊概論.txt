1.
{
    1. `lw $s1, 0($t1)`：將記憶體地址 3000 的內容（2000）讀取到寄存器 `$s1` 中。

    2. `sub $s2, $s2, $s2`：將寄存器 `$s2` 的值設置為零。

    3. `add $s2, $2, 100`：將寄存器 `$2` 的值和立即數 100 相加，然後將結果（值為 100）存儲到寄存器 `$s2` 中。

    4. `lw $s1, 0($s1)`：將記憶體地址 2000 的內容（4）讀取到寄存器 `$s1` 中。

    5. `add $s1, $s1, $s2`：將寄存器 `$s1` 的值（4）和寄存器 `$s2` 的值（100）相加，然後將結果（104）存儲到寄存器 `$s1` 中。

    6. `lw $s3, 0($t2)`：將記憶體地址 3004 的內容（1000）讀取到寄存器 `$s3` 中。

    7. `add $s3, $s3, $s2`：將寄存器 `$s3` 的值（1000）和寄存器 `$s2` 的值（100）相加，然後將結果（1100）存儲到寄存器 `$s3` 中。

    8. `sw $s3, 4($sl)`：將寄存器 `$s3` 的值（1100）寫入到記憶體地址 3000 + 4 = 3004 的地方。

    9. `sw $s1, 0($s1)`：將寄存器 `$s1` 的值（104）寫入到記憶體地址 3000 的地方。

    | memory address | content |    $s1=104
    | 1000           | 3000    |    $s2=100
    | 1004           | 4       |    $s3=1100
    | ......         | ......  |    $t1=3000
    | 2000           | 4       |    $t2=3004
    | 2004           | 1000    |
    | ......         | ......  |
    | 3000           | 104     |
    | 3004           | 1100    |
    | ......         | ......  |
}
2.
{
    (a)
        (1)immediate=2^16-1，即 65535
        (2)displacement=-2^(n-1)~2^(n-1)-1,n is the number of bits for the displacement field.
        (3)PC-related=(-2^15)~(2^15-1)
    
    (b)
        (1)R-type
        (2)I-type
        (3)I-type
}
3.
{
    (a)(0.9 * 10 ns + 0.6 * 40 ns + 0.4 * 12000040 ns) = 9ns + 24ns + 4800016 ns = 48000049 ns

    (b)作業系統可以透過多種方式來提高 CPU 利用率，其中一種方式是，在字組不在主記憶體中時，作業系統可以讓 CPU 執行其他工作，而不是空閒等待 12 ms 直到字組被載入主記憶體。

    例如，作業系統可以讓 CPU 執行以下工作：

    1.處理其他程式的請求。
    2.執行 I/O 操作。
    3.執行背景任務。
    這樣可以提高 CPU 的利用率，並減少系統的延遲。
}
4.
{
    (a)add是有符号数加法，addu是"无符号数"加法
        s3=0Xbfffffff
        s4=0X40000001
    
    (b)一顆 1 位元全加器有三個輸入：加數 A、加數 B 和進位輸入 Cin，以及兩個輸出：進位輸出 Cout 和和輸出 Sum。

    Cout 的邏輯函數如下： Cout = AB + AB * Cin 
    Sum  的邏輯函數如下： Sum = A + B + Cin

    4個1-bit的加法器組成4-bit的加法器，再將8個4-it的加法器組成32-bit的加法器

}
5.
{
    a)7
    b)2000.0000002 (2.0e-6 = 2.0*10 的-6 次方)
    c)true
}
6.
{
    Ans: 3113
}
7.
{
    
    
}
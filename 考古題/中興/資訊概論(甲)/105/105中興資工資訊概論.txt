1.X
2.X
3.O
4.X
5.X
6.
{
              12
        3            15
                 14      35
                        21 42
}
7.A
8.O(200^n)
9.-2147483648.
10.
{
    當使用貪婪法（Greedy Method）解決 0/1 背包問題時，並不總是能夠保證得到最優解，因為該方法僅考慮局部最優解，而忽略了全局或整體最優解。
    在 0/1 背包問題中，你有一個容量有限的背包以及一系列物品，每個物品都有自己的重量和價值。目標是在不超過背包容量的情況下，使背包中所放物品的價值總和最大化。
    讓我們舉個例子：
    背包容量 = 10
    物品：
    1. 物品 A - 價值 = 7，重量 = 6（價值/重量比 = 7/6 ≈ 1.17）
    2. 物品 B - 價值 = 8，重量 = 7（價值/重量比 = 8/7 ≈ 1.14）
    3. 物品 C - 價值 = 4，重量 = 3（價值/重量比 = 4/3 ≈ 1.33）
    使用基於價值/重量比的貪婪策略，該算法會首先選擇價值/重量比最高的物品，即物品 C。然後可能選擇下一個價值/重量比次高的物品 A。
    然而，這種貪婪策略將導致總價值為 11（物品 C 的價值為 4，物品 A 的價值為 7），總重量為 9（物品 C 的重量為 3，物品 A 的重量為 6）。它未考慮到選擇物品 B 而不是物品 A 將提供更好的整體解決方案，因為物品 B 在其重量上具有更高的價值。
    在這種情況下，最優解是選擇物品 B 和物品 C，這將使總價值為 12（物品 B 的價值為 8，物品 C 的價值為 4），總重量為 10（物品 B 的重量為 7，物品 C 的重量為 3）。這是在背包容量內能夠達到的最大價值。
    因此，基於價值/重量比的貪婪方法並不能始終導致 0/1 背包問題的最優解。
}
11.已問chegg
12.
{
    1.65
    2.A 
    3.66
    4.B
}
13.
{
    1.12
    2.14
    3.14
    4.16

}
14.
{
    for(k=0;k<=n;k++){
        sum+=power(-1,k)/(2n+1);
    }

    if(n==0)
        return 1;
    else{
        for(i=1;i<=n;i++){
            pow=pow*base;
        }
    }
}
15.
{
    (a) 參考局部性：這個概念指的是程序在任何特定時間點訪問其地址空間的一個相對較小的部分的趨勢。它包括兩個主要類型：
        1.時間局部性：表示如果訪問了一個記憶體位置，很可能在不久的將來會再次訪問該位置。
        2.空間局部性：表明如果訪問了一個記憶體位置，接下來很可能會訪問附近的記憶體位置（地址接近）。
        時間局部性和空間局部性是內存管理和緩存策略的基本原則，它們使內存緩存的使用更有效，減少了訪問較慢的內存層的頻率。
    (b) 反向頁表：在傳統的分頁系統中，使用頁表將虛擬頁映射到物理內存地址。反向頁表則是某些操作系統中用於內存管理的一種數據結構。與每個進程都有自己的頁表不同，反向頁表是一個全局數據結構，包含物理頁和虛擬頁之間的映射。
        它存儲了將物理頁框與相應的虛擬頁號碼和進程標識符關聯起來的條目。這種方法對於地址空間很大但物理內存有限的系統是有效的，因為它允許多個進程共享頁表。
    (c) 上下文切換：在多任務操作系統中，上下文切換指的是保存一個進程的 CPU 狀態並加載另一個進程的保存狀態，從而允許多個進程共享單個 CPU 資源。
        當發生上下文切換時，操作系統將正在運行進程的 CPU 當前狀態（包括程序計數器、寄存器和其他相關 CPU 狀態）保存到其進程控制塊（PCB）中。然後，從下一個要執行的進程的 PCB 中將保存的狀態加載到 CPU 中。上下文切換對於多任務很重要，它實現了在單個 CPU 上看似同時執行多個進程的效果。
}
16.
{
    (a) 雙模式操作是由 CPU 提供的。
    (b) 雙模式操作的目標是通過至少兩種模式來實現保護：用戶模式和核心模式。用戶程序在權限較低的用戶模式下運行，而操作系統在權限較高的核心模式下運行。CPU 硬件限制了用戶模式下的某些指令和內存訪問，以防止用戶程序干擾關鍵的操作系統功能或其他程序。
    (c) 完全在用戶模式下運行操作系統是不可能的。操作系統需要核心模式提供的特權和無限制的訪問權限，以管理硬件、執行關鍵操作和實施安全措施。
    (d) 如果一個在用戶模式下的進程關閉中斷，可能會導致系統不穩定。禁用中斷會阻止 CPU 對外部事件的響應或處理重要的系統任務，可能導致系統卡住或無法響應。
    (e) 從用戶模式切換到核心模式的可能情況包括：
    - 系統調用：當用戶程序向操作系統請求服務時。
    - 異常或陷阱：例如除以零、頁面錯誤或硬件中斷等需要操作系統介入的事件。
    - 特權指令：執行只允許在核心模式下的特定 CPU 指令。
}
17.
{
    處於 CPU 內的寄存器確實是極其快速的記憶體，用於保存頻繁訪問的數據或立即處理的指令。然而，進程控制塊（PCB）或處理器描述符也包含寄存器字段，原因如下：
    1. **上下文切換**：當發生上下文切換時，CPU 需要保存當前進程的狀態，然後切換到另一個進程。這包括保存當前進程正在使用的寄存器值，以便當進程恢復執行時，可以從中斷的地方繼續執行。將這些寄存器值保存在 PCB 中，使 CPU 能夠恢復進程的確切狀態，從而保證進程在下次運行時能夠正確執行。
    2. **進程信息**：PCB 中的寄存器可能存儲有關進程的重要信息，如其執行狀態、優先級、指向其內存空間的指針，或有關已打開的文件和資源的詳細信息。
    3. **中斷處理**：在中斷或異常情況下，CPU 可能需要暫時保存其當前狀態，包括寄存器值，以處理中斷並切換到中斷服務例程。將寄存器值保存在 PCB 中，可以確保順利處理中斷，並確保 CPU 能夠準確返回到先前的任務。
    4. **進程特定數據**：某些寄存器可能保存與進程特定的數據，如堆棧指針或程序計數器。將這些信息存儲在 PCB 中可以確保 CPU 能夠在恢復進程時保持所有必要的上下文信息完整。
    總的來說，PCB 或處理器描述符中的寄存器字段充當了 CPU 狀態的快照，特定於一個進程，有助於實現高效的上下文切換和正確的進程管理。
}
18.
{
    page table = | 8 | valid |
                 | 2 | valid |
                 | 7 | valid |
                 | - | invalid |
                 | 4 | valid |
}
19.
{
    (a)X
    (b)O
    (c)O
    (d)O
    (e)X
}
20.
{
    (a)Basic block: a sequence of instructions without branches (except possibly at the end) and
       without branch targets or branch labels (except possibly at the beginning)
    (b)Number of blocks = 4096 / 16 = 256
       Number of sets = 256 / 2 = 128 = 27
       Tag size = 32 -7-4 = 21
    (c)40%
}

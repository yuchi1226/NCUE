1.
{
    1. `lw $s1, 0($t1)`：將記憶體地址 3000 的內容（2000）讀取到寄存器 `$s1` 中。

    2. `sub $s2, $s2, $s2`：將寄存器 `$s2` 的值設置為零。

    3. `add $s2, $2, 100`：將寄存器 `$2` 的值和立即數 100 相加，然後將結果（值為 100）存儲到寄存器 `$s2` 中。

    4. `lw $s1, 0($s1)`：將記憶體地址 2000 的內容（4）讀取到寄存器 `$s1` 中。

    5. `add $s1, $s1, $s2`：將寄存器 `$s1` 的值（4）和寄存器 `$s2` 的值（100）相加，然後將結果（104）存儲到寄存器 `$s1` 中。

    6. `lw $s3, 0($t2)`：將記憶體地址 3004 的內容（1000）讀取到寄存器 `$s3` 中。

    7. `add $s3, $s3, $s2`：將寄存器 `$s3` 的值（1000）和寄存器 `$s2` 的值（100）相加，然後將結果（1100）存儲到寄存器 `$s3` 中。

    8. `sw $s3, 4($sl)`：將寄存器 `$s3` 的值（1100）寫入到記憶體地址 3000 + 4 = 3004 的地方。

    9. `sw $s1, 0($s1)`：將寄存器 `$s1` 的值（104）寫入到記憶體地址 3000 的地方。

    | memory address | content |    $s1=104
    | 1000           | 3000    |    $s2=100
    | 1004           | 4       |    $s3=1100
    | ......         | ......  |    $t1=3000
    | 2000           | 4       |    $t2=3004
    | 2004           | 1000    |
    | ......         | ......  |
    | 3000           | 104     |
    | 3004           | 1100    |
    | ......         | ......  |
}
2.
{
    (a)
        (1)immediate=2^15-1
        (2)displacement=2^15-1
        (3)PC-related=(-2^15)~(2^15-1)
    
    (b)
        (1)R-type
        (2)I-type
        (3)I-type
}
3.
{
    (a)(0.9 * 10 ns + 0.6 * 40 ns + 0.4 * 12000040 ns) = 9ns + 24ns + 4800016 ns = 48000049 ns

    (b)作業系統可以透過多種方式來提高 CPU 利用率，其中一種方式是，在字組不在主記憶體中時，作業系統可以讓 CPU 執行其他工作，而不是空閒等待 12 ms 直到字組被載入主記憶體。

    例如，作業系統可以讓 CPU 執行以下工作：

    1.處理其他程式的請求。
    2.執行 I/O 操作。
    3.執行背景任務。
    這樣可以提高 CPU 的利用率，並減少系統的延遲。
}
4.
{
    (a)add是有符号数加法，addu是"无符号数"加法
        s3=0Xbfffffff
        s4=0X40000001
    
    (b)一顆 1 位元全加器有三個輸入：加數 A、加數 B 和進位輸入 Cin，以及兩個輸出：進位輸出 Cout 和和輸出 Sum。

    Cout 的邏輯函數如下： Cout = AB + AB * Cin 
    Sum  的邏輯函數如下： Sum = A + B + Cin

    4個1-bit的加法器組成4-bit的加法器，再將8個4-it的加法器組成32-bit的加法器

}
5.
{
    a)7
    b)2000.0000002 (2.0e-6 = 2.0*10 的-6 次方)
    c)true
}
6.
{
    Ans: 3113
}
7.
{
    
    
}
8.
{
    (1)我找不出錯誤QQ

    (2)    | P | W | Ne | N |
        P  | 0 | 53| 54 | 48|
        W  | 53| 0 | 18 | 30|
        Ne | 54| 18|  0 | 12|
        N  | 48| 30| 12 |  0| 

}
9.d
10.
{
    (a)31.6/3=10.53
    (b)19/3=6.3
    (c)average waiting=((1-1)+(2-0.4)+(6-0))/3=2.53
       average turnaround time=((2-1)+(6-0.4)+(14-0))/3=6.87
}
11.
{
    (a)Samaphores（信號量）是一種用於處理多個進程或執行緒之間共享資源存取的同步機制。Semaphore 是一個計數器，用於控制對共享資源的訪問，以確保同一時間只有一個進程（或執行緒）可以訪問該資源，從而防止資源競爭和確保一致性。
    (b)Race Condition（競爭條件）是指多個process共享同個資源 & Context Switch，因為process的執行順序不同，而造成取得的資料結果不同
    (c)trashing(擁塞):當系統的虛擬記憶體中有太多的頁面（或稱為虛擬頁面）被不斷地交換入和交換出，而這種頻繁的頁面交換導致系統變得極度繁忙，效能急劇下降的現象。
    (d)Demand paging（需求分頁）是一種虛擬記憶體管理技術，用於操作系統中，特別是在支持虛擬記憶體的系統中。這種技術允許操作系統僅在程序真正需要時，才將程序的某些部分（頁面）加載到主記憶體（RAM）中。
    (e)fragmentation（碎片化）是指在記憶體或磁盤中出現的空間分割和浪費的現象。這種分割可以分為兩種主要類型：外部碎片化和內部碎片化。
}
12.
{
    A=[19,3,5,1,2,4,6,7,11,10,8,0] 
    it=0,i=0,gt=11, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[3,19,5,1,2,4,6,7,11,10,8,0]
    it=1,i=2,gt=11, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[3,5,19,1,2,4,6,7,11,10,8,0]
    it=2,i=3,gt=11, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[3,5,1,19,2,4,6,7,11,10,8,0]
    it=3,i=4,gt=11, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[3,5,1,2,19,4,6,7,11,10,8,0]
    it=4,i=5,gt=11, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[3,5,1,2,4,19,6,7,11,10,8,0]
    it=5,i=6,gt=11, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[3,5,1,2,4,6,19,7,11,10,8,0]
    it=6,i=7,gt=11, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[3,5,1,2,4,6,7,19,11,10,8,0]
    it=7,i=8,gt=11, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[3,5,1,2,4,6,7,11,19,10,8,0]
    it=8,i=9,gt=11, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[3,5,1,2,4,6,7,11,10,19,8,0]
    it=9,i=10,gt=11, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[3,5,1,2,4,6,7,11,10,8,19,0]
    it=10,i=11,gt=11, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[3,5,1,2,4,6,7,11,10,8,0,19]
    it=11,i=12,gt=11, 此時i>gt, 第一次排序結束

    整個數組分為3個區
    第一區(<it)裡所有的數字都比19小
    第二區(it~gt)裡所有的數字都等於19
    第三區(>gt)裡所有的數字都比19大

    此時還需對第一區、第三區進行quick sort

    A=[3,5,1,2,4,6,7,11,10,8,0,19]
    it=0,i=1,gt=10, A[it]<A[i] swapA[i],A[gt] gt--

    A=[3,0,1,2,4,6,7,11,10,8,5,19]
    it=0,i=1,gt=9, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[0,3,1,2,4,6,7,11,10,8,5,19]
    it=1,i=2,gt=9, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[0,1,3,2,4,6,7,11,10,8,5,19]
    it=2,i=3,gt=9, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[0,1,2,3,4,6,7,11,10,8,5,19]
    it=3,i=4,gt=9, A[it]<A[i] swapA[i],A[gt] gt--

    A=[0,1,2,3,8,6,7,11,10,4,5,19]
    it=3,i=4,gt=8, A[it]<A[i] swapA[i],A[gt] gt--

    A=[0,1,2,3,10,6,7,11,8,4,5,19]
    it=3,i=4,gt=7, A[it]<A[i] swapA[i],A[gt] gt--

    A=[0,1,2,3,11,6,7,10,8,4,5,19]
    it=3,i=4,gt=6, A[it]<A[i] swapA[i],A[gt] gt--

    A=[0,1,2,3,7,6,11,10,8,4,5,19]
    it=3,i=4,gt=5, A[it]<A[i] swapA[i],A[gt] gt--

    A=[0,1,2,3,6,7,10,11,8,4,5,19]
    it=3,i=4,gt=5, A[it]<A[i] swapA[i],A[gt] gt--

    A=[0,1,2,3,7,6,11,10,8,4,5,19]
    it=3,i=4,gt=4, A[it]<A[i] swapA[i],A[gt] gt--

    A=[0,1,2,3,7,6,11,10,8,4,5,19]
    it=3,i=4,gt=3, 此時i>gt, 第二次排序結束

    整個數組分為3個區
    第一區(<it)裡所有的數字都比3小
    第二區(it~gt)裡所有的數字都等於3
    第三區(>gt)裡所有的數字都比3大

    此時還需對第一區、第三區進行quick sort

    第一區已排序好，在此省略，下為第三區之排序

    A=[0,1,2,3,7,6,11,10,8,4,5,19]
    it=4,i=5,gt=10, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[0,1,2,3,6,7,11,10,8,4,5,19]
    it=5,i=6,gt=10, A[it]<A[i] swapA[i],A[gt] gt--

    A=[0,1,2,3,6,7,5,10,8,4,11,19]
    it=5,i=6,gt=9, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[0,1,2,3,6,5,7,10,8,4,11,19]
    it=6,i=7,gt=9, A[it]<A[i] swapA[i],A[gt] gt--

    A=[0,1,2,3,6,5,7,4,8,10,11,19]
    it=6,i=7,gt=8, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[0,1,2,3,6,5,4,7,8,10,11,19]
    it=7,i=8,gt=8, A[it]<A[i] swapA[i],A[gt] gt--

    A=[0,1,2,3,6,5,4,7,8,10,11,19]
    it=7,i=8,gt=7, 此時i>gt, 第三次排序結束

    A=[0,1,2,3,6,5,4,7,8,10,11,19]
    it=4,i=5,gt=6, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[0,1,2,3,5,6,4,7,8,10,11,19]
    it=5,i=6,gt=6, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[0,1,2,3,5,4,6,7,8,10,11,19]
    it=6,i=7,gt=6, 此時i>gt, 第四次排序結束

    A=[0,1,2,3,5,4,6,7,8,10,11,19]
    it=4,i=5,gt=5, A[it]>A[i] swapA[it],A[i] it++ i++

    A=[0,1,2,3,4,5,6,7,8,10,11,19]
    it=5,i=6,gt=5, 此時i>gt, 第五次排序結束

}
13.
{
    如果系統滿足這四個條件，那麼就會發生死鎖。

    1.互斥:每次只能有一個處理程序能使用該資源，如果另一程序對該資源提出申請，其必須等待，直到該資源被釋放為止
    2.hold and wait:存在一處理程序，其至少持有一個資源，而又在等待另一個正被其他其它處理程序所持有的資源
    3.no preemption:一個資源只能由持有他的處理程序在完成工作之後自願釋放
    4.circular wait:處理程序各自握有資源，且彼此等待對方的資源
}
14.
{
    ChatGPT

    解決這個問題的一種有效方法是使用雙指針技巧。這種方法的基本思想是固定一個元素，然後使用兩個指針來搜索其後的元素，檢查是否存在兩個元素的和等於這個固定的元素。由於這個問題是要求找到所有符合條件的三元組，所以我們可以通過固定每個元素來進行遍歷。
}
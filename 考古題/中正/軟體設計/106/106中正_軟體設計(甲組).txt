1.
2. 22
3.
{
    1
    1
}
4.
{
    A=7
    B=3
    C=5
    D=5
    E=4
}
5. 31
6.
{
    (a)
    void swap(int *x, int *y) {
        int temp = *x;
        *x = *y;
        *y = temp;
    }

    (b)
    void swap(int &x, int &y) {
        int temp = x;
        x = y;
        y = temp;
    }
}
7.
{
    double temp = A[i][j];
    A[i][j] = A[j][i];
    A[j][i] = temp;
}
8.
{
    (1) 編譯器拒絕這段程式碼是因為多重繼承的歧義。
        類 B 和 C 都繼承自類 A，而他們都在其建構函式中嘗試與 a 互動。
        當 D 物件建立時，它會繼承兩個 A 的副本：一個是透過 B，另一個是透過 C。
        編譯器無法決定要先呼叫哪個 A 的建構函式，導致未定義的行為。

    (2) 解決歧義的方法
        要解決這個問題，請將 A 設為虛基類，在 B 和 C 的繼承宣告中使用 virtual 關鍵字：
        class B: public virtual A { ... };
        class C: public virtual A { ... };

    (3) 9

    (4)斷言和虛函數
    這段程式碼再次被拒絕是因為切片。當將 Y 物件分配給 B 指標時，僅考慮物件的 B 部分，而 Y 內的 A 子物件無法通過 b 訪問。
    解決方案
    要解決此問題，請將類 Y 添加一個虛 get 方法，該方法呼叫 Y 內的 A 子物件的 get 方法：
    class Y : public D, public X {
        public:
            virtual int get() override { return A::get(); }  // 呼叫 `A` 的 `get()` 方法
    };
    這會確保通過 b 呼叫的 get 方法訪問 Y 內的正確 a 值，使斷言有效。
}
9.
10.
11.
12.
13.
1.
{
    (1)D
    (2)B
    (3)C
    (4)A
    (5)A
    (6)C
    (7)D
    (8)D
    (9)A
    (10)E
}
2.
{
    64TB(https://tl2cents.github.io/2021/07/18/USTC%20OS%202021%20Spring%20HW5/)
}
3.
{
    (a)YES
    (b)YES
}
4.https://gateoverflow.in/302815/gate-cse-2019-question-33
{
    (a) 2^45 pages. (X)
    (b) 60          (X)
    (c) 2^55 bytes. (X)
}
5.
{
    2.2x DmuL
}
6.
{
    10
}
7.
{
    當然！快取優化涉及增強快取性能的不同策略。以下是優化每個快取指標的方法：

    1. **命中時間優化**：
    - **增加相關性**：更高的相關性允許更靈活地存儲數據，減少在快取中查找數據的時間。從直接映射到組相關或全相關快取的轉變可以提高命中時間。
    - **使用更快的技術**：使用更快的快取技術，例如具有更快訪問時間的靜態隨機存取記憶體（SRAM）或優化快取訪問機制（例如預取），可以降低命中時間。

    2. **未命中率優化**：
    - **增加快取大小**：更大的快取可以容納更多數據，減少快取未命中的可能性，因為它可以保存更頻繁訪問的數據。
    - **改進替換策略**：實施更好的替換策略（例如最近最少使用 - LRU）可以最小化淘汰重要或經常使用的數據的可能性。

    3. **未命中懲罰優化**：
    - **使用多級快取**：實施多級快取層次（L1、L2、L3快取）有助於減少未命中的懲罰。靠近 CPU 的更小、更快的快取（L1和L2）可以降低未命中的懲罰，因為它們的訪問時間比更大但更慢的快取（L3）低。
    - **使用預取技術**：預測未來的記憶體訪問並將數據預取到快取中，可以減少未命中的影響，降低未命中時提取數據的時間。
}
8.
{
    (a) 對於32位元的變數，如果一個地址是4的倍數，則它是對齊的。如果它不是4的倍數，那麼它就是未對齊的。
    在給定的地址序列中第一個未對齊的記憶體訪問是182。

    (b) 對於8位元（1位元）變數，假設在 CPU 和主記憶體之間存在一個直接映射的快取，每個快取具有 10 個區塊，每個區塊只能容納 1 位元組的數據：
    快取區塊將以直接映射的方式存儲來自記憶體的數據。快取索引由地址對區塊數量取模得到（快取索引=地址 mod 10）。
    第一次具有“快取命中”的讀取訪問是當兩個不同的記憶體訪問具有相同的快取索引時。
    根據給定的地址，第一次“快取命中”發生在地址88。

    (c) 4 hit

    (d) 88

    (e) 4 hit
}


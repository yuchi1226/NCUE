資料結構
{
    1.
    (1) 18 + 17 * 16 + (15 * 14 + 13) * 12
        2966

    (2) 簡單均勻哈希：
        簡單均勻哈希指的是一種方法，其中每個元素被哈希到哈希表的任何槽位的概率是相等的，且與其他元素獨立無關。
        這種方法假設每個鍵被哈希到哈希表的任何槽位的概率是相等的。

        對於一個具有 'm' 個槽位並存儲 'n' 個元素的哈希表，使用鏈式解決哈希碰撞（在每個槽位使用鏈表來處理碰撞），一次失敗搜索所需的預期時間涉及計算平均所需的比較次數。

        對於哈希表中的鏈式解決方法：
        表中列表的平均長度為 n/m。
        失敗搜索所需的預期時間與哈希槽位上鏈表的長度成正比，該槽位是如果元素存在則應該位於的位置。
        因此，在具有鏈式解決碰撞的簡單均勻哈希中，失敗搜索所需的預期時間為 O(n/m)，這意味著它與鏈中的平均元素數成正比。


    (3) 紅黑樹的特性（除了二叉搜索樹的特性）:
        1.每個節點都是紅色或黑色。
        2.根是黑色的。
        3.所有葉子（NIL 節點）都是黑色的。
        4.如果一個節點是紅色的，那麼它的兩個子節點都是黑色的。
        5.從一個節點到其後代葉子的每條路徑都具有相同數量的黑色節點。
        轉換步驟:
        1.將所有節點都染成紅色。
        2.從樹的底部開始，逐漸向上，根據需要執行樹旋轉和顏色更改以強制執行紅黑屬性。
        3.在插入和刪除期間使用特定的程序，如“重新著色”和“重新平衡”，以保持這些屬性。

    (4) nlogn、n^2、n^2、nlogn

    (5) BFS: ABCDFES
        DFS: ABCDEFS

    2.
    (1) 如果一個圖的每一個頂點都可從該圖其他任意一點到達，則稱該圖是強連通的。
        在任意有向圖中能夠實現強連通的部分我們稱其為強連通元件。
        判斷一個圖是否為強連通以及找到一個圖強連通元件只需要線性時間（Θ(V + E)）

    (2) B 樹對於磁碟存儲很有優勢，因為它的結構允許每個節點包含更多的鍵值。
        這降低了樹的高度，意味著要定位特定數據所需的訪問層級更少。
        因為每個層級通常需要進行單獨的磁盤讀取，B 樹比其他樹結構有更寬的分支因子，從而減少了需要的磁盤 I/O 操作數量。 

    (3)

    (4) 二項堆的兩個屬性
        1.結構：二項堆是一個二項樹的集合，每個二項樹具有唯一的度數，並遵循二項堆的屬性：度為 k 的二項樹的根具有度為 k-1 的子節點，對於 0 <= k <= n。
        2.操作：二項堆支持高效的插入、合并和查找最小元素操作，時間複雜度為 O(log n)。
        3.關鍵屬性
            結構屬性：強制二項堆內的二項樹具有特定的結構。
            堆屬性：確保父節點的鍵始終小於或等於其子節點的鍵，保持堆的順序。

    3.
    (1) 定義：競爭條件是指多個線程或進程以未同步的方式訪問和操作共享數據，導致取決於事件發生時間的不可預測結果。
        解決方案：
            同步：使用互斥量、信號量或監視器等機制來控制對共享資源的訪問，確保一次只能一個線程可以修改它們。
            原子操作：使用硬體或軟體提供的原子操作，保證不可分割的執行，防止其他線程的干擾。

    (2) 死鎖預防 vs. 死鎖避免：
        死鎖預防：採用策略防止死鎖的發生，確保死鎖所需的必要條件（互斥、持有與等待、無抢占、循環等待）中至少有一個不成立。
        死鎖避免：使用方法允許系統進入死鎖狀態，但具有檢測和恢復的機制。例如，在資源分配中使用銀行家算法來避免進入死鎖狀態。

    (3) 目的：用於根據特定條件同步線程，允許線程在某個事件發生之前繼續。
        場景：
            1.指示任務完成：線程可以向正在等待條件變量的其他線程發出完成信號。
            2.等待資源：線程可以等待資源可用後才能訪問它們。
            3.生產者-消費者模式：協調生產者和消費者線程，以確保有效地傳輸數據。
            4.實現屏障：將多個線程同步到達一個共同點之前繼續。

    (4) 異步和延遲取消目標線程的區別是什麼？
        異步取消：目標線程立即被中斷並可能被終止，即使它正在進行操作。可能導致不一致的狀態或資源泄漏。
        延遲取消：目標線程會收到取消請求的通知，但允許它完成當前操作後才優雅地終止。確保更清潔的資源清理，避免意外行為。

    (5) 導致進程終止的條件：
        1.正常終止：進程完成其執行並終止。
        2.錯誤終止：出現錯誤條件導致進程終止。
        3.致命錯誤：發生無法處理的關鍵錯誤，導致進程終止。
        4.被其他進程終止：另一個進程或系統強制終止進程。

    4.
    (1) 分頁的好處：
        1.簡化記憶體管理：分頁可將物理記憶體分為固定大小的區塊（頁），將邏輯記憶體分為相同大小的區塊（框架），有助於更容易地進行記憶體管理。
        2.無需連續分配：使用分頁，不需要連續分配記憶體。它能更有效地利用物理記憶體，允許非連續分配頁面。

    (2) 工作集：指進程在執行期間活動使用的頁面集合。保留工作集於記憶體中有助於防止過多的頁錯誤並通過確保必要頁面可用來優化性能。
        抖動：當操作系統不斷地在記憶體中交換頁面，因為沒有足夠的物理記憶體來支持所有活躍進程的工作集時發生。
              這導致系統花費更多時間交換頁面而不是執行指令，嚴重降低了性能。

    (3) 外部碎片：當空閒記憶體被分割成較小的、不連續的區塊時會發生，這些區塊無法滿足對較大區塊的分配請求，即使總的空閒空間足夠。
        內部碎片：當分配的記憶體區塊比實際存儲的數據大時會發生，浪費了每個區塊中的未使用空間。

    (4) 同步 I/O：在同步 I/O 操作中，進程在 I/O 操作完成之前會等待。它會將 I/O 操作與程序執行同步。
        非同步 I/O：非同步 I/O 允許進程在 I/O 操作進行時繼續執行。系統在 I/O 操作完成時通知進程，不會阻塞進程，允許同時執行其他任務。

    (5) 數據寄存器：存儲從裝置傳輸的數據或傳送到裝置的數據。
        狀態寄存器：指示裝置狀態（忙碌、就緒、錯誤等）的寄存器。
        控制寄存器：用於控制裝置操作（啟動、停止、中斷等）的寄存器。
        地址寄存器：用於在裝置和記憶體之間傳輸數據的存儲器地址。

    5.
    (1) 最小權限原則： 最小權限原則指的是使用者或程式應僅擁有完成任務所需的最低權限或許可權。
        在Solaris 10中，系統透過 RBAC（基於角色的存取控制）來實現這一原則。
        Solaris 使用 RBAC 來管理特定的權限，系統管理員可以定義角色並賦予這些角色特定的權限，確保使用者只能獲得執行任務所需的權限，而沒有不必要的存取權限。

    (2) 病毒： 電腦病毒是一種惡意程式，會附加到合法程式或文件上，在執行這些程式/文件時進行複製。
                病毒需要人為干預來傳播，通常通過共享感染的文件或執行感染的程式。
        蠕蟲： 相對地，電腦蠕蟲是一種獨立的惡意程式，會在沒有人為干預的情況下在網路上進行自我複製。
                蠕蟲會利用網路服務或作業系統中的漏洞，在計算機之間進行傳播。

    (3) 處理UNIX中setuid-on問題的常見解決方案：
        1.功能權限： 這種方法涉及將根權限分解為更小、更具體的權限，使進程僅在需要時提升其權限。
        2.安全編程實踐： 確保程式不過度依賴setuid權限，而是使用更安全的編程實踐，以減少對提升權限的需求。

    (4) 偽裝和重放攻擊：
        偽裝： 當攻擊者通過篡改數據偽裝成另一個使用者或系統時發生。例如，使用他人的憑證未經授權地訪問系統。
        重放攻擊： 在重放攻擊中，攻擊者攔截並重用在系統之間傳輸的數據，以試圖冒充有效使用者。例如，截取登錄憑證並重放它們以未經授權地訪問系統。

    (5) 身份驗證和非否認
        1.身份驗證:
            1.驗證嘗試訪問系統或資源的用戶或實體的身份。
            2.常用方法包括密碼、生物特徵識別和令牌。
        2.非否認:
            1.防止實體否認其參與通信或交易。
            2.通過數位簽名或其他加密技術實現。
}

計算機
{
    1. 
    (1) 0/0000 0000/000 0000 0000 0000 0000 0000

    (2) 1/0111 1110/000 0000 0000 0000 0000 0000

    (3) 1.111 1111 1111 1111 1111 1111 * 2^127

    (4) 1.000 0000 0000 0000 0000 0000 * 2^-126

    (5) 0.000 0000 0000 0000 0000 0001 * 2^-126

    (6) +-0、+-∞、NaN
        +-(1.111 1111 1111 1111 1111 1111*2^127 ~ 1.000 0000 0000 0000 0000 0000*2^-126)
        +-(0.111 1111 1111 1111 1111 1111*2^-126 ~ 0.000 0000 0000 0000 0000 0001*2^-126)
    
    (7) NO
        例如說:
        0 00000001 00000000000000000000000 和 0 00000001 00000000000000000000001 的距離是 0.00000000000000000000001*2^-126
        0 11111110 00000000000000000000000 和 0 11111110 00000000000000000000001 的距離是 0.00000000000000000000001*2^127
    
    (8) Yes，相鄰兩數的距離同為2^-16
    
    (9) 最大正整數0111 1111 1111 1111.1111 1111 1111 1111 = ((2^15)-1)+(1-(2^-16)) = 32768
        最大負整數1000 0000 0000 0000.0000 0000 0000 0000 = -2^15 = 32768
    
    (10) step1 exponent ailgment
         step2 significant add/sub
         step3 normalization
         step4 rounding
         每一步都需要至少一clock cycle

    2.
    (1) 1.5625
    (2) 0.25%
    (3) 3.64
    (4) 1.23
    
    3.
    (1) 20MHz

    (2) total latency = 5200ns
        throughput = 100/5200=20*10^6 instruction/sec
        average CPI = 1.04
        
    (3) 
    
    (4) 資料危障:當計畫的指令無法在正確的時鐘週期執行，因為指令所需的資料尚不可用
        如果不進行干預，資料危障可能會嚴重阻礙管道

    (5) 超級管道是將給定管道的階段分解成更小的階段，從而使管道更深，進而提高產量
        優點:
            1.減少週期時間，提高產量
            2.增加ILP(Instruction-level parallelism)
            3.提高加速比
        缺點:
            1.增加管道危險的處罰
            2.增加stage-latency的平衡難度
            3.增加管道的實現複雜度

    4.
    (1) 147K
    (2) 148K
    (3) 157K
    (4) 
    (5) 2ns 
    (6) 2.72
    (7) 5.4
    (8) 6.6

    5.
    (1) 單指令多資料（SIMD）的優勢在於能夠使用單一指令同時處理多個資料元素，這可以大幅提升效能。
        在傳統 CPU 中，SIMD 的多個運算單元由同一控制單元驅動，使得所有資料可以平行執行同一指令，這稱為單指令多資料（SIMD）。
        在 GPU 中，SIMD 則是以每個串流多處理器（SM）為基礎運作。它對資料串流執行一個通用指令，導致所有執行緒同時執行相同的指令，這被稱為單指令多執行緒（SIMT）。

    (2) 控制風險：當正確的指令無法在正確的流水線時鐘周期內執行，是因為提取的指令不是所需的指令。
        分支預測可用於改善性能下降。也就是說，通過預測分支是否發生，可以繼續在流水線中執行分支指令。
        如果預測錯誤，正在提取和解碼的指令將被丟棄（刷新）。

    (3) 時間局部性：如果引用了一個項目，它很可能很快再次被引用。
        空間局部性：如果引用了一個項目，其地址附近的項目很可能很快被引用。
        在循環中提取指令或資料利用了時間局部性，
        順序訪問數組中的資料項目展示了空間局部性。

    (4) 靜態多發：一種實現多發處理器的方法，許多決策在執行之前由編譯器做出。
        動態多發：一種實現多發處理器的方法，在執行期間由處理器做出許多決策。
    
}

數學
{
    
}